\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{palatino}
\usepackage[breaklinks=true]{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage[left=3cm, right=2cm, top=3cm, bottom=2cm]{geometry}
\geometry{a4paper}
\usepackage{fancyhdr}
\usepackage[brazilian]{babel}
\usepackage{siunitx}
\usepackage{subcaption}
\sisetup{detect-all}
\usepackage{float}
\usepackage{ragged2e}
\usepackage{examplep}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt} 
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}
\graphicspath{{figuras/}}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{cleveref}
\usepackage{spverbatim}
\usepackage[framed,numbered,autolinebreaks,useliterate]{mcode}
\setlength{\parskip}{1em}
\usepackage{xspace}
\usepackage{amsmath}
\usepackage{gensymb}
\usepackage{booktabs}
\usepackage{minted}
\usepackage{listings}
\usepackage{bm}
\usepackage{indentfirst}
\usepackage{algorithm}
\usepackage{algpseudocode, lipsum}
\lstset{
    literate={~} {$\sim$}{1}
}
\usepackage[shortlabels]{enumitem}

\newcommand{\MATLAB}{\textsc{Matlab}\xspace}
\newcommand{\SIMULINK}{\textsc{Simulink}\xspace}
\newcommand{\pspice}{\textsc{PSpice}\xspace}
\newcommand{\tinkercad}{\textsc{TinkerCad}\xspace}
\newcommand{\arduino}{\textsc{Arduino}\xspace}
\newcommand{\sen}{\hspace{2pt}\mathrm{sen}}
\newcommand{\counts}{\textit{counts}\xspace}
\newcommand{\FT}{\text{F.T.}}
\newcommand{\zeros}{\text{Zeros}}
\newcommand{\polos}{\text{Polos}}
\newcommand{\software}{\textit{software}\xspace}
\newcommand{\hardware}{\textit{hardware}\xspace}


\newenvironment{brprocess}[1][]
  {\begin{algorithm}[#1]
     \selectlanguage{brazilian}%
     \floatname{algorithm}{Processo}%
     \renewcommand{\algorithmicif}{\textbf{se}}%
     \renewcommand{\algorithmicfor}{\textbf{para}}%
     \renewcommand{\algorithmicdo}{\textbf{faça}}%
     \renewcommand{\algorithmicthen}{\textbf{faça}}%
     \renewcommand{\algorithmicend}{\textbf{fim}}%
     \renewcommand{\algorithmicwhile}{\textbf{enquanto}}%
     \renewcommand{\algorithmicelse}{\textbf{caso contrário}}%
     % Set other language requirements
  }
  {\end{algorithm}}

  \newenvironment{bralgorithm}[1][]
  {\begin{algorithm}[#1]
     \selectlanguage{brazilian}%
     \floatname{algorithm}{Algoritmo}%
     \renewcommand{\algorithmicif}{\textbf{se}}%
     \renewcommand{\algorithmicfor}{\textbf{para}}%
     \renewcommand{\algorithmicdo}{\textbf{faça}}%
     \renewcommand{\algorithmicthen}{\textbf{faça}}%
     \renewcommand{\algorithmicend}{\textbf{fim}}%
     \renewcommand{\algorithmicwhile}{\textbf{enquanto}}%
     \renewcommand{\algorithmicelse}{\textbf{caso contrário}}%
     % Set other language requirements
  }
  {\end{algorithm}}

\begin{document}
\begin{titlepage}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
	
\centering

\includegraphics[width=0.15\textwidth]{logo-unicamp.pdf}\\[0.5cm]	
\textsc{\Large Universidade Estadual de Campinas}\\[2.0cm]
\textsc{\large Faculdade de Engenharia Elétrica e de Computação}\\[0.5cm]
	
\textsc{IA707/EG507 - Computação Evolutiva}\\[2.5cm]
	
{\LARGE \bfseries EFC I}\\[3.5cm]

\begin{minipage}[t]{0.4\textwidth}
	\begin{flushleft}
    \textit{Alunos}\\
    João Pedro O. Pagnan - 199727\\
    João Pedro M. Ferreira - 218762
	\end{flushleft}
\end{minipage}
~
\begin{minipage}[t]{0.4\textwidth}
	\begin{flushright}
		\textit{Professor}\\
		Levy Boccato
	\end{flushright}
\end{minipage}\\[4.5cm]

{Campinas, \today}
	
\vfill\vfill\vfill\vfill\vfill

\includegraphics[width=0.2\textwidth]{logo-feec.png}\\[0.5cm]
\vfill 
	
\end{titlepage}

\justify

Neste exercício, vamos abordar a instância do QAP tratada em \cite{elshafei1977hospital}, que estudou a alocação de 19 clínicas em um departamento do Hospital Ahmed Maher, no Cairo, Egito, considerando o fluxo de pacientes entre elas, com o auxílio de um algoritmo genético (GA, do inglês \textit{genetic algorithm}). O arquivo \Pverb|elshafei QAP.mat| traz a matriz $\mathbf{W}$ com os fluxos previstos entre as instalações, assim como a matriz $\mathbf{D}$ com as distâncias entre as localidades.

\textbf{a) Escolha uma representação adequada para as soluções candidatas e uma função de avaliação (\textit{fitness}). Discuta as razões que o motivaram a tais escolhas, além de apontar a cardinalidade do espaço de busca.}

Uma representação possível para as soluções deste problema seria considerar cada solução seja representada por um vetor $\mathbf{x} \in \mathbb{N}^n$, sendo $n$ o número de instalações e localidades, tal que:
$$\mathbf{x} = [x_1 \; x_2 \; ... \; x_{n}]^T,$$ 
sendo que $0 \leq x_o \leq n - 1$ para $o \in \mathbb{N}, 0 \leq o \leq n - 1$, de forma que a posição de cada elemento do vetor $\mathbf{x}$ simboliza uma localização e o valor do elemento, dado por $p \in \mathbb{N}, 0 \leq p \leq n - 1$, representa a $p$-ésima instalação.

Esta representação foi escolhida pois, além de ser a utilizada em \cite{elshafei1977hospital}, permite representar cada solução por um vetor de $n$ inteiros entre 1 e $n$, ou seja, representar cada solução como se fosse uma cadeia de números, facilitando a aplicação de diversos operadores de mutação. Caso fossemos representar cada solução por uma matriz $n \times n$, em que $x_{ij} \in 0, 1, 0 \leq i, j \leq n$, a aplicação desses operadores seria mais complexa.

A representação escolhida possui cardinalidade $n!$, afinal, trata-se da permu\-tação de um conjunto de $n$ elementos, indicando que, caso $n$ for muito grande, uma solução por força bruta demorará para chegar na solução ótima, ou nem a alcançará.

A função de avaliação que será utilizada é uma variação da função custo. No caso, deseja-se minimizar a seguinte função custo:
\begin{equation}\label{eq:custo}
    f(\mathbf{x}) = \sum_{i = 0}^{n - 1}  \sum_{j = 0}^{n - 1} \bm{D_{ij}} \bm{W_{x_{i} x_{j}}},
\end{equation}
sendo $D_{ij}$ a distância entre as localidades $i$ e $j$ e $W_{x_{i} x_{j}}$ o fluxo entre as instalações dadas por $x_i$ e $x_j$, respectivamente. 

Como a função custo está relacionada a uma minimização, foi realizado um mapeamento dela para o algoritmo genético buscar maximizar o \textit{fitness}, dado por:
\begin{equation}\label{eq:fitness}
    \phi(f(\mathbf{x})) = \frac{1/f(\mathbf{x})}{1/17212548}
\end{equation}

Com isso, valores menores da função custo das soluções produzem \textit{fitness} maiores e, como o algoritmo busca maximizar esta grandeza, ele irá o menor custo. 

Também vale ser ressaltado que, como o custo ótimo do problema é conhecido, seu valor foi utilizado para que a função de ajuste fique num intervalo entre 0 e 1, sendo que este último corresponde a solução ótima.

\textbf{b) Descreva um algoritmo genético adaptado ao QAP tendo em vista a codificação adotada. Justifique as escolhas feitas com relação aos operadores (e.g., seleção) e parâmetros do algoritmo (e.g., tamanho da população e critério de parada).}

O algoritmo genético a ser utilizado possui as seguintes etapas:
\begin{enumerate}
    \item Gerar a população inicial com $N$ indivíduos;
    \item Calcular o \textit{fitness} para cada indivíduo da população;
    \item Aplicar o operador de seleção para selecionar dois indivíduos baseado em seus \textit{fitness};
    \item Aplicar o operador de recombinação para gerar dois descendentes;
    \item Aplicar o operador de mutação nos descendentes para que os respectivos cromossomos tenham uma probabilidade $p_m$ de serem mutados;
    \item Caso o número total de indivíduos e descendentes for menor que $2N$, repetir do passo 2 ao 6;
    \item Calcular o \textit{fitness} dos descendentes;
    \item Eliminar os $N$ indivíduos de menor \textit{fitness};
    \item Repetir do passo 3 ao 8 até o critério de parada ser atingido.
\end{enumerate}

A \textbf{geração da população inicial} será da seguinte forma, sendo $N$ o tamanho da população e $n$ o número de instalações e localidades:
\begin{brprocess}[H]
\textbf{Paramêtros}: Tamanho da população desejada e tamanho do cromossomo\\
\textbf{Saída}: População gerada
\caption{Geração aleatória da população inicial (\Pverb|gerar_pop(N, n)|)}
\begin{algorithmic}
\State população $\gets [\;]$
\State $i\gets 0$

\While{$i < N$}
    \State cromossomo $\gets [\;]$
    \State $j \gets 0$
    \While{$j < n$}
        \State gene $\gets$ alelo $\in \{0, 2, ..., n - 1\}$
        \While{gene $\in$ cromossomo}
            \State gene $\gets$ alelo $\in \{0, 2, ..., n - 1\}$
        \EndWhile
        \State cromossomo $[j] \gets$ gene
        \State $j \gets j + 1$
    \EndWhile
    \State \textit{fitness} $\gets 0$
    \State custo $\gets 0$
    \State população $[i] \gets$ [cromossomo, \textit{fitness}, custo]
    \State $i \gets i + 1$
\EndWhile
\State \textbf{retorna} população
\end{algorithmic}
\end{brprocess}

Vale ser mencionado que, para esta representação, composta por uma permutação de $n$ números diferentes, a quantidade de alelos é igual ao tamanho do cromossomo. Além disso, cada indivíduo da população irá armazenar o seu cromossomo, seu valor de \textit{fitness} e seu custo.

O \textbf{cálculo do \textit{fitness}} seguirá a equação \ref{eq:fitness} e pode ser descrito pelo seguinte algoritmo:
\begin{brprocess}[H]
\textbf{Entradas}: população, matriz com as distâncias e matriz com os fluxos\\
\textbf{Saída}: população com os valores de \textit{Fitness} e custo atualizados

\caption{Cálculo do \textit{fitness} e do custo (\Pverb|calc_fitness_qap(populacao, D, W)|)}
\begin{algorithmic}

\For{indivíduo \textbf{em} população}
    \If{indivíduo[1] = 0}
        \State{custo = \Pverb|calc_custo_qap(indivíduo, D, W)|}
        \State{fitness = (1/custo)/(1/17212548)}
        \State indivíduo[1] = fitness
        \State indivíduo[2] = custo
    \EndIf
\EndFor
\State \textbf{retorna} população
\end{algorithmic}
\end{brprocess}

A função \Pverb|calc_custo_qap()| calcula o custo para a respectiva solução. Com isso, o algoritmo determina os valores da função de avalização e do custo de cada indivíduo da população.

Na quarta etapa, o GA aplica o \textbf{operador de seleção de torneio} na população. Esse método utiliza o parâmetro $q$, que é igual a quantidade de indivíduos da população selecionados por torneio. Esse método é executado duas vezes no algoritmo genético, de forma a determinar dois pais para a recombinação e é descrito da seguinte forma:
\begin{brprocess}[H]
    \caption{Operador de seleção por torneio (\Pverb|selecao_torneio(populacao, N, q_torneio)|}
    \textbf{Entrada:} população\\
    \textbf{Parâmetros}: quantidade de indivíduos da população selecionados por torneio e tamanho da população inicial\\
    \textbf{Saída}: o melhor indivíduo escolhido no torneio
    \begin{algorithmic}
            \State $i \gets 0$
            \State indivíduos participantes $\gets [\;]$
            \While{$i < q$}
                \State índice indivíduo $\gets n \in \{0, 1, 2, ..., N - 1\}$
                \State indivíduos participantes $[i] \gets$ população [indivíduo]
                \State $i \gets i + 1$
            \EndWhile
            \State indice do melhor indivíduo $\gets$ indivíduos participantes[\Pverb|argmax|(indivíduos participantes [:,1]])
            \State melhor indivíduo $\gets$ indivíduos participantes[índice do melhor indivíduo]
            \State \textbf{retorna} melhor indivíduo
    \end{algorithmic}
\end{brprocess}

Este operador foi escolhido por possibilitar o ajuste da pressão seletiva na população pelo parâmetro $q$.

Em seguida, na quinta etapa, o operador de recombinação que será aplicado foi o método de \textit{crossover} ordenado (OX1), devido a sua facilidade de implementar e por permitir ser aplicado a permutações. Sendo $P1$ e $P2$ os pais e $D1$ e $D2$ os descendentes, esse método é descrito por:
\begin{brprocess}[H]
    \caption{Operador de recombinação (\Pverb|crossover_ox1(cromossomo_p1, cromossomo_p2)|)}
    \textbf{Entrada}: cromossomo dos dois pais\\
    \textbf{Saída}: cromossomo de ambos os filhos
    \begin{algorithmic}
        \State $i \gets 0$
        \State pais $\gets [cromossomo_p1, cromossomo_p2]$
        \State n_{alelos} $$\gets $ \Pverb|len(cromossomo_p1)|
        \State descendentes $\gets [\;]$
        \While{$i < 2$}
            \State cromossomo do descendente $\gets [\;]$
            \State posição de corte 1 $\gets p \in \{0, 1, 2, ..., n - 2\}$
            \State posição de corte 2 $\gets p \in \{$posição de corte 1$,$ posição de corte 1 + 1$, ..., n - 1\}$
            \State seção do cromossomo $\gets$ pais $[i][$posição de corte 1 : posição de corte 2$]$
            \State cromossomo do descendente $[$posição de corte 1 : posição de corte 2$] \gets$ seção do cromossomo
            \State locus $\gets 0$
            \State locus pai $\gets 0$
            \While{locus $< n_{alelos}$}
                \If{locus $<$ posição de corte 1 \textbf{ou} locus $>$ posição de corte 2}
                    \While{pais$[$i - 1$][$locus pai$] \in$ cromossomo do descendente}
                        \State locus $\gets$ locus pai $+1$
                    \EndWhile
                    \State cromossomo do descendente$[$locus$]$ $\gets $ pais$[i - 1][$locus pai$]$
                    \State locus $\gets$ locus + 1
                    \State locus pai $\gets$ locus + 1
                \Else
                    \State locus $\gets$ locus $+ 1$
                \EndIf
            \EndWhile
            \State descendentes $[i]\gets$ [cromossomo do descendente, 0, 0]
            \State $i \gets i + 1$
        \EndWhile
    \end{algorithmic}
\end{brprocess}

Como pode ser observado, decidiu-se que será utilizada apenas uma seção do cromossomo do pai escolhido para o descendente e esta seção não será circular. Isso foi escolhido para facilitar a implementação do código e ainda assim permitir que haja uma recombinação das permutações.

Por fim, resta detalhar o operador de mutação utilizado. Neste caso, foi escolhido a mutação de reverter a ordem dos genes presentes em um segmento do cromossomo. Além disso, foi escolhido que a mutação tem uma probabilidade $p_m$ de acontecer, ou seja, dela não acontecer no cromossomo do descendente e ser mantido o cromossomo original.

O processo pode ser descrito da seguinte forma:
\begin{brprocess}[H]
    \caption{Operador de mutação (\Pverb|mutacao_reversao(cromossomo)|)}
    \textbf{Entrada}: cromossomo a ser mutado\\
    \textbf{Parâmetros}: probabilidade da mutação ocorrer\\
    \textbf{Saída}: cromossomo mutado
    \begin{algorithmic}
        \State{número $\gets k \in \{0, ..., p_m\}, k \in \mathbb{R}$}
        \If{número $<= p_m$}
            \State $n \gets $ \Pverb|len(cromossomo)|
            \State cromossomo mutado $\gets [\;]$
            \State índice 1 $\gets i \in \{0, 1, 2, ..., n - 2\}$
            \State índice 2 $\gets i \in \{$índice 1 $+ 1, $índice 1 $+ 2, ..., n - 1\}$
            \State $i \gets 0$
            \State $j \gets 0$
            \While{$i < n$}
                \If{$i \geq$ índice 1 \textbf{e} $i \leq$ índice 2}
                    \State cromossomo mutado $[i] \gets$ cromossomo $[$índice 2 $- j]$
                    \State $j \gets j + 1$
                \Else
                    \State cromossomo mutado $[i] \gets$ cromossomo $[i]$
                \EndIf
                \State$i \gets i + 1$
        \EndWhile
    \end{algorithmic}
\end{brprocess}

Novamente, escolhemos não considerar o cromossomo e o genótipo como algo circular para facilitar a programação deste operador.

Com isso, foram descritos os operadores escolhidos para serem utilizados na geração de indivíduos desse algoritmo genético.

Estes operadores serão executados nessa sequência até que a população tenha $2N$ soluções, quando ocorrerá uma eliminação dos $N$ indivíduos de menor \textit{fitness}. Esse processo será repetido até o critério de parada ser atingido. No caso, o critério de parada escolhido foi o número de gerações $n_g$.

Esse algoritmo tem, portanto, os seguintes parâmetros:
\begin{listing}
    \item $N$: tamanho da população inicial;
    \item $q$: quantidade de indivíduos presentes no torneio;
    \item $p_m$: probabilidade de ocorrer uma mutação;
    \item $n_g$: número de gerações
\end{listing}

O valor de cada parâmetro foi determinado de maneira exploratória, e os valores escolhidos foram:
\begin{table}[H]
    \centering
    \begin{tabular}{c|c}
        $N$ & 1000\\
        $q$ & 10\\
        $p_m$ & 0.5\\
        $n_g$ & 10\\
    \end{tabular}
    \caption{Caption}
    \label{tab:my_label}
\end{table}

\textbf{c) Execute o GA construído no item b) 10 vezes, gerando, em cada caso, uma população inicial aleatória. Apresente a melhor solução obtida pelo algoritmo e o respectivo custo em cada execução. Além disso, compute o custo médio e o desvio padrão nesse conjunto de execuções. Comente.}

Executando o algoritmo construído no item anterior 10 vezes foram obtidas as seguintes melhores soluções e custos:

\textbf{d) Para cada uma das 10 realizações do item c), apresente as curvas de custo médio da população, bem como do custo do melhor indivíduo (ou seja, do custo mínimo) em função do número de gerações. Discuta o desempenho do algoritmo à luz dos resultados obtidos, das curvas de custo geradas e das próprias características do problema.}

\textbf{e) Implemente, por fim, uma busca aleatória e faça 10 execuções independentes considerando a mesma quantidade de avaliações da função de \textit{fitness} que o GA consumiu. Compare os resultados obtidos pelos dois métodos.}

\newpage

\bibliographystyle{ieeetr}

\bibliography{bib}

\pdfinfo{
   /Title  (IA707 - EFC I - 199727 e 218762)
}

a\end{document}